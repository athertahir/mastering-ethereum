/// @notice To create a limit order for buying the _symbolBuy while selling the _symbolSell.
/// @param _symbolBuy The 3 character or more name of the token to buy.
/// @param _symbolSell The 3 character or more name of the token to sell.
/// @param _priceBid The price for how many _symbolBuy tokens you desire to buy. For instance: buy 10 ETH for 1 BTC.
/// @param _priceAsk The price for how many tokens you desire to sell of the _symbolSell in exchange for the _symbolBuy. For instance: sell 10 BTC for 2 ETH.
function createLimitOrder(bytes32 _symbolBuy, bytes32 _symbolSell, uint256 _priceBid, uint256 _priceAsk) public {}


function createLimitOrder("ETH","BTC", 90, 7);


function createLimitOrder("BTC", "ETH", 10, 20);


/// @notice The function to create market orders by filling existing limit orders
/// @param _type The type of the market order which can be "Buy" or "Sell"
/// @param _symbol The token that we want to buy or sell
/// @param _maxPrice The maximum price we are willing to sell or buy the token for, set it to 0 to not limit the order
function createMarketOrder(bytes32 _type, bytes32 _symbol, uint256 _maxPrice);




pragma solidity 0.5.4;

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function totalSupply() external view returns (uint256);
    function balanceOf(address who) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Escrow {
    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner, 'You must be the owner to execute that function');
        _;
    }

    /// @notice This contract does not accept ETH transfers
    function () external { revert(); }

    /// @notice To setup the initial tokens that the user will store when creating the escrow
    /// @param _owner The address that will be the owner of this escrow, must be the owner of the tokens
    constructor (address _owner) public {
        require(_owner != address(0), 'The owner address must be set');
        owner = _owner;
    }

    /// @notice To transfer tokens to another address, usually the buyer or seller of an existing order
    /// @param _token The address of the token to transfer
    /// @param _to The address of the receiver
    /// @param _amount The amount of tokens to transfer
    function transferTokens(address _token, address _to, uint256 _amount) public onlyOwner {
        require(_token != address(0), 'The token address must be set');
        require(_to != address(0), 'The receiver address must be set');
        require(_amount > 0, 'You must specify the amount of tokens to transfer');

        require(IERC20(_token).transfer(_to, _amount), 'The transfer must be successful');
    }

    /// @notice To see how many of a particular token this contract contains
    /// @param _token The address of the token to check
    /// @return uint256 The number of tokens this contract contains
    function checkTokenBalance(address _token) public view returns(uint256) {
        require(_token != address(0), 'The token address must be set');
        return IERC20(_token).balanceOf(address(this));
    }
}



import React from 'react'
import ReactDOM from 'react-dom'
import './index.styl'

class Main extends React.Component {
    constructor() {
        super()
    }

    render() {
        return (
            <div>
                <Sidebar />
            </div>
        )
    }
}

/// Create the basic sidebar html, then we'll add the style css
// The sidebar where you take all your actions
class Sidebar extends React.Component {
    constructor() {
        super()
        this.state = {
            showLimitOrderInput: false
        }
    }

    render() {
        return (
            <div className="sidebar">
                <div className="selected-assets-title">Selected assets:</div>
                <div className="selected-asset-one">ETH</div>
                <div className="selected-asset-two">BAT</div>
                <div className="your-portfolio">Your portfolio:</div>
                <div className="grid-center">ETH:</div><div className="grid-center">10</div>
                <div className="grid-center">BAT:</div><div className="grid-center">200</div>
                <div className="money-management">Money management:</div>
                <button className="button-outline">Deposit</button>
                <button className="button-outline">Withdraw</button>
                <div className="actions">Actions:</div>
                <button>Buy</button>
                <button className="sell">Sell</button>
                <select defaultValue="market-order" onChange={selected => {
                    if(selected.target.value == 'limit-order') this.setState({showLimitOrderInput: true})
                    else this.setState({showLimitOrderInput: false})
                }}>
                    <option value="market-order">Market Order</option>
                    <option value="limit-order">Limit Order</option>
                </select>
                <input ref="limit-order-amount" className={this.state.showLimitOrderInput ? '' : 'hidden'} type="number" placeholder="Price to buy or sell at..."/>
            </div>
        )
    }
}



npm i -S style-loader css-loader stylus-loader stylus



{
    test: /\.styl$/,
    exclude: /node_modules/,
    use: ['style-loader', 'css-loader', 'stylus-loader']
}




*
    box-sizing: border-box;

body
    margin: 0
    font-family: sans-serif

button
    background-color: rgb(98, 133, 223)
    cursor: pointer
    color: white
    border-radius: 10px
    border: none
    box-shadow: 1px 1px 10px 0px #adadad

    &:hover
        opacity: 0.7

input
    padding: 15px
    border-radius: 2px
    border: 2px solid grey

select
    -webkit-appearance: none
    -moz-appearance: none
    appearance: none
    padding: 15px
    border-radius: 0
    border: 2px solid rgb(98, 133, 223)
    color: rgb(98, 133, 223)
    cursor: pointer

.button-outline
    background-color: transparent
    border: 2px solid grey
    color: grey
    box-shadow: none

.hidden
    display: none

.sidebar
    width: 20%
    height: 100vh
    background-color: rgb(245, 245, 245)
    padding: 3%
    display: grid
    grid-template-columns: 1fr 1fr
    grid-template-rows: 20px 50px 20px 20px 20px 20px 50px 20px 50px 50px 50px
    grid-column-gap: 8px
    grid-row-gap: 15px

    .selected-assets-title
        grid-column: 1 / span 2
        align-self: center

    .selected-asset-one
        font-size: 15pt
        align-self: center
        justify-self: center

    .selected-asset-two
        font-size: 15pt
        align-self: center
        justify-self: center

    .your-portfolio
        grid-column: 1 / span 2
        align-self: center

    .grid-center
        align-self: center
        justify-self: center

    .money-management
        grid-column: 1 / span 2

    .actions
        grid-column: 1 / span 2
        align-self: center

    .sell
        background-color: rgb(223, 98, 98)

    select
        grid-column: 1 / span 2
        align-self: center

    input
        grid-column: 1 / span 2
        align-self: center




        import React from 'react'
        import ReactDOM from 'react-dom'
        import './index.styl'

        class Main extends React.Component {
            constructor() {
                super()

                this.state = {
                    trades: [{
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 123,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 120, // You want to buy 120 firstSymbol
                        price: 200 // When buying, you get 1 firstSymbol for selling 200 secondSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 80, // You want to buy 80 secondSymbol
                        price: 305 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }],
                    history: [{
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2,
                        price: 20
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2,
                        price: 20
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2,
                        price: 20
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'sell',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }, {
                        id: 927,
                        type: 'buy',
                        firstSymbol: 'ETH',
                        secondSymbol: 'BAT',
                        quantity: 2, // You want to buy 80 secondSymbol
                        price: 10 // When selling, you get 305 secondSymbol for selling 1 firstSymbol
                    }]
                }
            }

            render() {
                return (
                    <div className="main-container">
                        <Sidebar />
                        <Trades
                            trades={this.state.trades}
                        />
                        <History
                            history={this.state.history}
                        />
                    </div>
                )
            }
        }

        /// Create the basic sidebar html, then we'll add the style css
        // The sidebar where you take all your actions
        class Sidebar extends React.Component {
            constructor() {
                super()
                this.state = {
                    showLimitOrderInput: false
                }
            }

            render() {
                return (
                    <div className="sidebar">
                        <div className="selected-assets-title heading">Selected assets</div>
                        <div className="selected-asset-one">ETH</div>
                        <div className="selected-asset-two">BAT</div>
                        <div className="your-portfolio heading">Your portfolio</div>
                        <div className="grid-center">ETH:</div><div className="grid-center">10</div>
                        <div className="grid-center">BAT:</div><div className="grid-center">200</div>
                        <div className="money-management heading">Money management</div>
                        <button className="button-outline">Deposit</button>
                        <button className="button-outline">Withdraw</button>
                        <div className="actions heading">Actions</div>
                        <button>Buy</button>
                        <button className="sell">Sell</button>
                        <select defaultValue="market-order" onChange={selected => {
                            if(selected.target.value == 'limit-order') this.setState({showLimitOrderInput: true})
                            else this.setState({showLimitOrderInput: false})
                        }}>
                            <option value="market-order">Market Order</option>
                            <option value="limit-order">Limit Order</option>
                        </select>
                        <input ref="limit-order-amount" className={this.state.showLimitOrderInput ? '' : 'hidden'} type="number" placeholder="Price to buy or sell at..."/>
                    </div>
                )
            }
        }

// The main section to see live trades taking place
class Trades extends React.Component {
    constructor() {
        super()
    }

    render() {
        let buyTrades = this.props.trades.filter(trade => trade.type == 'buy')
        buyTrades = buyTrades.map((trade, index) => (
            <div key={trade.id + index} className="trade-container buy-trade">
                <div className="trade-symbol">{trade.firstSymbol}</div>
                <div className="trade-symbol">{trade.secondSymbol}</div>
                <div className="trade-pricing">{trade.type} {trade.quantity} {trade.firstSymbol} at {trade.price} {trade.secondSymbol} each</div>
            </div>
        ))
        let sellTrades = this.props.trades.filter(trade => trade.type == 'sell')
        sellTrades = sellTrades.map((trade, index) => (
            <div key={trade.id + index} className="trade-container sell-trade">
                <div className="trade-symbol">{trade.firstSymbol}</div>
                <div className="trade-symbol">{trade.secondSymbol}</div>
                <div className="trade-pricing">{trade.type} {trade.quantity} {trade.firstSymbol} at {trade.price} {trade.secondSymbol} each</div>
            </div>
        ))
        return (
            <div className="trades">
                <div className="buy-trades-title heading">Buy</div>
                <div className="buy-trades-container">{buyTrades}</div>
                <div className="sell-trades-title heading">Sell</div>
                <div className="sell-trades-container">{sellTrades}</div>
            </div>
        )
    }
}



        *
            box-sizing: border-box;

        body
            margin: 0
            font-family: sans-serif

        button
            background-color: rgb(98, 133, 223)
            cursor: pointer
            color: white
            border-radius: 10px
            border: none
            box-shadow: 1px 1px 10px 0px #adadad

            &:hover
                opacity: 0.7

        input
            padding: 15px
            border-radius: 2px
            border: 2px solid grey

        select
            -webkit-appearance: none
            -moz-appearance: none
            appearance: none
            padding: 15px
            border-radius: 0
            border: 2px solid rgb(98, 133, 223)
            color: rgb(98, 133, 223)
            cursor: pointer

        .button-outline
            background-color: transparent
            border: 2px solid grey
            color: grey
            box-shadow: none

        .heading
            text-transform: uppercase
            font-size: 10pt

        .hidden
            display: none

        .main-container
            display: grid
            grid-template-columns: 20% 50% 30%

        .sidebar
            height: 100vh
            background-color: whitesmoke
            padding: 15px
            display: grid
            grid-template-columns: 1fr 1fr
            grid-template-rows: 20px 50px 20px 20px 20px 20px 50px 20px 50px 50px 50px
            grid-column-gap: 8px
            grid-row-gap: 15px

            .selected-assets-title
                grid-column: 1 / span 2
                align-self: center

            .selected-asset-one
                font-size: 15pt
                align-self: center
                justify-self: center

            .selected-asset-two
                font-size: 15pt
                align-self: center
                justify-self: center

            .your-portfolio
                grid-column: 1 / span 2
                align-self: center

            .grid-center
                align-self: center
                justify-self: center

            .money-management
                grid-column: 1 / span 2

            .actions
                grid-column: 1 / span 2
                align-self: center

            .sell
                background-color: rgb(223, 98, 98)

            select
                grid-column: 1 / span 2
                align-self: center

            input
                grid-column: 1 / span 2
                align-self: center

        .trades
            height: 100vh
            background-color: #e8e8e8
            padding: 15px
            display: grid
            grid-template-rows: auto 1fr auto 1fr
            overflow: auto

            .buy-trades-container, .sell-trades-container
                display: grid
                grid-row-gap: 4px

            .buy-trades-title
                grid-column: 1 / 2
                grid-row: 1 / 2

            .sell-trades-title
                grid-column: 2 / 3
                grid-row: 1 / 2

            .trade-container
                justify-self: center
                align-self: center
                padding: 10px
                width: 300px
                height: 50px
                color: white
                margin-right: 10px
                display: grid
                grid-template-columns: 1fr 1fr

                & div:nth-child(1)
                    align-self: center
                    justify-self: center

                & div:nth-child(2)
                    align-self: center
                    justify-self: center

                .trade-pricing
                    grid-column: 1 / span 2
                    align-self: center
                    justify-self: center
                    font-size: 10pt

                    &:first-letter
                        text-transform: uppercase

            .buy-trade
                background-color: rgb(98, 133, 223)

            .sell-trade
                background-color: rgb(223, 98, 98)


// Past historical trades
class History extends React.Component {
    constructor() {
        super()
    }

    render() {
        const historicalTrades = this.props.history.map((trade, index) => (
            <div key={trade.id + index} className="historical-trade">
                <div className={trade.type == 'sell' ? 'sell-trade' : 'buy-trade'}>{trade.type} {trade.quantity} {trade.firstSymbol} for {trade.quantity * trade.price} {trade.secondSymbol} at {trade.price} each</div>
            </div>
        ))
        return (
            <div className="history">
                <div className="heading">Recent history</div>
                <div className="historical-trades-container">{historicalTrades}</div>
            </div>
        )
    }
}


ReactDOM.render(<Main />, document.querySelector('#root'))



.history
    padding: 15px
    background-color: whitesmoke
    height: 100vh
    overflow: auto

    .historical-trades-container
        text-align: center

        .historical-trade
            font-size: 0.95em
            margin-bottom: 10px

            &:first-letter
                text-transform: uppercase

            .sell-trade
                color: rgb(223, 98, 98)

            .buy-trade
                color: rgb(98, 133, 223)



// Functions that we need:
/*
    1. Constructor to setup the owner
    2. Fallback non-payable function to reject ETH from direct transfers since we only want people to use the functions designed to trade a specific pair
    3. Function to extract tokens from this contract in case someone mistakenly sends ERC20 to the wrong function
    4. Function to create whitelist a token by the owner
    5. Function to create market orders
    6. Function to create limit orders
 */

pragma solidity ^0.5.4;

import './Escrow.sol';

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function totalSupply() external view returns (uint256);
    function balanceOf(address who) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract DAX {
    event TransferOrder(bytes32 _type, address indexed from, address indexed to, bytes32 tokenSymbol, uint256 quantity);
    enum OrderState {OPEN, CLOSED}

    struct Order {
        uint256 id;
        address owner;
        bytes32 orderType;
        bytes32 firstSymbol;
        bytes32 secondSymbol;
        uint256 quantity;
        uint256 price;
        uint256 timestamp;
        OrderState state;
    }

    Order[] public buyOrders;
    Order[] public sellOrders;
    Order[] public closedOrders;
    uint256 public orderIdCounter;
    address public owner;
    address[] public whitelistedTokens;
    bytes32[] public whitelistedTokenSymbols;
    address[] public users;

    // Token address => isWhitelisted or not
    mapping(address => bool) public isTokenWhitelisted;
    mapping(bytes32 => bool) public isTokenSymbolWhitelisted;
    mapping(bytes32 => bytes32[]) public tokenPairs; // A token symbol pair made of 'FIRST' => 'SECOND'
    mapping(bytes32 => address) public tokenAddressBySymbol; // Symbol => address of the token
    mapping(uint256 => Order) public orderById; // Id => trade object
    mapping(uint256 => uint256) public buyOrderIndexById; // Id => index inside the buyOrders array
    mapping(uint256 => uint256) public sellOrderIndexById; // Id => index inside the sellOrders array
    mapping(address => address) public escrowByUserAddress; // User address => escrow contract address

    modifier onlyOwner {
        require(msg.sender == owner, 'The sender must be the owner for this function');
        _;
    }

    /// @notice Users should not send ether to this contract
    function () external {
        revert();
    }

    constructor () public {
        owner = msg.sender;
    }

     /// @notice To whitelist a token so that is tradable in the exchange
     /// @dev If the transaction reverts, it could be because of the quantity of token pairs, try reducing the number and breaking the transaction into several pieces
     /// @param _symbol The symbol of the token
     /// @param _token The token to whitelist, for instance 'TOK'
    /// @param _tokenPairSymbols The token pairs to whitelist for this new token, for instance: ['BAT', 'HYDRO'] which will be converted to ['TOK', 'BAT'] and ['TOK', 'HYDRO']
    /// @param _tokenPairAddresses The token pair addresses to whitelist for this new token, for instance: ['0x213...', '0x927...', '0x128...']
    function whitelistToken(bytes32 _symbol, address _token, bytes32[] memory _tokenPairSymbols, address[] memory _tokenPairAddresses) public onlyOwner {}

    /// @notice To store tokens inside the escrow contract associated with the user accounts as long as the users made an approval beforehand
    /// @dev It will revert is the user doesn't approve tokens beforehand to this contract
    /// @param _token The token address
    /// @param _amount The quantity to deposit to the escrow contract
    function depositTokens(address _token, uint256 _amount) public {}

    /// @notice To extract tokens
    /// @param _token The token address to extract
    /// @param _amount The amount of tokens to transfer
    function extractTokens(address _token, uint256 _amount) public {}

    /// @notice To create a market order by filling one or more existing limit orders at the most profitable price given a token pair, type of order (buy or sell) and the amount of tokens to trade, the _quantity is how many _firstSymbol tokens you want to buy if it's a buy order or how many _firstSymbol tokens you want to sell at market price
    /// @param _type The type of order either 'buy' or 'sell'
    /// @param _firstSymbol The first token to buy or sell
    /// @param _secondSymbol The second token to create a pair
    /// @param _quantity The amount of tokens to sell or buy
    function marketOrder(bytes32 _type, bytes32 _firstSymbol, bytes32 _secondSymbol, uint256 _quantity) public {}

    /// @notice To create a market order given a token pair, type of order, amount of tokens to trade and the price per token. If the type is buy, the price will determine how many _secondSymbol tokens you are willing to pay for each _firstSymbol up until your _quantity or better if there are more profitable prices. If the type if sell, the price will determine how many _secondSymbol tokens you get for each _firstSymbol
    /// @param _type The type of order either 'buy' or 'sell'
    /// @param _firstSymbol The first symbol to deal with
    /// @param _secondSymbol The second symbol that you want to deal
    /// @param _quantity How many tokens you want to deal, these are _firstSymbol tokens
    /// @param _pricePerToken How many tokens you get or pay for your other symbol, the total quantity is _pricePerToken * _quantity
    function limitOrder(bytes32 _type, bytes32 _firstSymbol, bytes32 _secondSymbol, uint256 _quantity, uint256 _pricePerToken) public {}

    /// @notice Sorts the selected array of Orders by price from lower to higher if it's a buy order or from highest to lowest if it's a sell order
    /// @param _type The type of order either 'sell' or 'buy'
    /// @return uint256[] Returns the sorted ids
    function sortIdsByPrices(bytes32 _type) public view returns (uint256[] memory) {}

    /// @notice Checks if a pair is valid
    /// @param _firstSymbol The first symbol of the pair
    /// @param _secondSymbol The second symbol of the pair
    /// @returns bool If the pair is valid or not
    function checkValidPair(bytes32 _firstSymbol, bytes32 _secondSymbol) public view returns(bool) {}


    /// @notice Returns the token pairs
    /// @param _token To get the array of token pair for that selected token
    /// @returns bytes32[] An array containing the pairs
    function getTokenPairs(bytes32 _token) public view returns(bytes32[] memory) {}
}



/// @notice To whitelist a token so that is tradable in the exchange
/// @dev If the transaction reverts, it could be because of the quantity of token pairs, try reducing the number and breaking the transaction into several pieces
/// @param _symbol The symbol of the token
/// @param _token The token to whitelist, for instance 'TOK'
/// @param _tokenPairSymbols The token pairs to whitelist for this new token, for instance: ['BAT', 'HYDRO'] which will be converted to ['TOK', 'BAT'] and ['TOK', 'HYDRO']
/// @param _tokenPairAddresses The token pair addresses to whitelist for this new token, for instance: ['0x213...', '0x927...', '0x128...']
function whitelistToken(bytes32 _symbol, address _token, bytes32[] memory _tokenPairSymbols, address[] memory _tokenPairAddresses) public onlyOwner {
    require(_token != address(0), 'You must specify the token address to whitelist');
    require(IERC20(_token).totalSupply() > 0, 'The token address specified is not a valid ERC20 token');
    require(_tokenPairAddresses.length == _tokenPairSymbols.length, 'You must send the same number of addresses and symbols');

    isTokenWhitelisted[_token] = true;
    isTokenSymbolWhitelisted[_symbol] = true;
    whitelistedTokens.push(_token);
    whitelistedTokenSymbols.push(_symbol);
    tokenAddressBySymbol[_symbol] = _token;
    tokenPairs[_symbol] = _tokenPairSymbols;

    for(uint256 i = 0; i < _tokenPairAddresses.length; i++) {
        address currentAddress = _tokenPairAddresses[i];
        bytes32 currentSymbol = _tokenPairSymbols[i];
        tokenPairs[currentSymbol].push(_symbol);
        if(!isTokenWhitelisted[currentAddress]) {
            isTokenWhitelisted[currentAddress] = true;
            isTokenSymbolWhitelisted[currentSymbol] = true;
            whitelistedTokens.push(currentAddress);
            whitelistedTokenSymbols.push(currentSymbol);
            tokenAddressBySymbol[currentSymbol] = currentAddress;
        }
    }
}



/// @notice To store tokens inside the escrow contract associated with the user accounts as long as the users made an approval beforehand
/// @dev It will revert is the user doesn't approve tokens beforehand to this contract
/// @param _token The token address
/// @param _amount The quantity to deposit to the escrow contract
function depositTokens(address _token, uint256 _amount) public {
    require(isTokenWhitelisted[_token], 'The token to deposit must be whitelisted');
    require(_token != address(0), 'You must specify the token address');
    require(_amount > 0, 'You must send some tokens with this deposit function');
    require(IERC20(_token).allowance(msg.sender, address(this)) >= _amount, 'You must approve() the quantity of tokens that you want to deposit first');
    if(escrowByUserAddress[msg.sender] == address(0)) {
        Escrow newEscrow = new Escrow(address(this));
        escrowByUserAddress[msg.sender] = address(newEscrow);
        users.push(msg.sender);
    }
    IERC20(_token).transferFrom(msg.sender, escrowByUserAddress[msg.sender], _amount);
}

/// @notice To extract tokens
/// @param _token The token address to extract
/// @param _amount The amount of tokens to transfer
function extractTokens(address _token, uint256 _amount) public {
    require(_token != address(0), 'You must specify the token address');
    require(_amount > 0, 'You must send some tokens with this deposit function');
    Escrow(escrowByUserAddress[msg.sender]).transferTokens(_token, msg.sender, _amount);
}



/// @notice To create a market order given a token pair, type of order, amount of tokens to trade and the price per token. If the type is buy, the price will determine how many _secondSymbol tokens you are willing to pay for each _firstSymbol up until your _quantity or better if there are more profitable prices. If the type if sell, the price will determine how many _secondSymbol tokens you get for each _firstSymbol
/// @param _type The type of order either 'buy' or 'sell'
/// @param _firstSymbol The first symbol to deal with
/// @param _secondSymbol The second symbol that you want to deal
/// @param _quantity How many tokens you want to deal, these are _firstSymbol tokens
/// @param _pricePerToken How many tokens you get or pay for your other symbol, the total quantity is _pricePerToken * _quantity
function limitOrder(bytes32 _type, bytes32 _firstSymbol, bytes32 _secondSymbol, uint256 _quantity, uint256 _pricePerToken) public {
    address userEscrow = escrowByUserAddress[msg.sender];
    address firstSymbolAddress = tokenAddressBySymbol[_firstSymbol];
    address secondSymbolAddress = tokenAddressBySymbol[_secondSymbol];

    require(firstSymbolAddress != address(0), 'The first symbol has not been whitelisted');
    require(secondSymbolAddress != address(0), 'The second symbol has not been whitelisted');
    require(isTokenSymbolWhitelisted[_firstSymbol], 'The first symbol must be whitelisted to trade with it');
    require(isTokenSymbolWhitelisted[_secondSymbol], 'The second symbol must be whitelisted to trade with it');
    require(userEscrow != address(0), 'You must deposit some tokens before creating orders, use depositToken()');
    require(checkValidPair(_firstSymbol, _secondSymbol), 'The pair must be a valid pair');

    Order memory myOrder = Order(orderIdCounter, msg.sender, _type, _firstSymbol, _secondSymbol, _quantity, _pricePerToken, now, OrderState.OPEN);
    orderById[orderIdCounter] = myOrder;
    if(_type == 'buy') {
        // Check that the user has enough of the second symbol if he wants to buy the first symbol at that price
        require(IERC20(secondSymbolAddress).balanceOf(userEscrow) >= _quantity, 'You must have enough second token funds in your escrow contract to create this buy order');

        buyOrders.push(myOrder);

        // Sort existing orders by price the most efficient way possible, we could optimize even more by creating a buy array for each token
        uint256[] memory sortedIds = sortIdsByPrices('buy');
        delete buyOrders;
        buyOrders.length = sortedIds.length;
        for(uint256 i = 0; i < sortedIds.length; i++) {
            buyOrders[i] = orderById[sortedIds[i]];
            buyOrderIndexById[sortedIds[i]] = i;
        }
    } else {
        // Check that the user has enough of the first symbol if he wants to sell it for the second symbol
        require(IERC20(firstSymbolAddress).balanceOf(userEscrow) >= _quantity, 'You must have enough first token funds in your escrow contract to create this sell order');

        // Add the new order
        sellOrders.push(myOrder);

        // Sort existing orders by price the most efficient way possible, we could optimize even more by creating a sell array for each token
        uint256[] memory sortedIds = sortIdsByPrices('sell');
        delete sellOrders; // Reset orders
        sellOrders.length = sortedIds.length;
        for(uint256 i = 0; i < sortedIds.length; i++) {
            sellOrders[i] = orderById[sortedIds[i]];
            sellOrderIndexById[sortedIds[i]] = i;
        }
    }

    orderIdCounter++;
}

/// @notice Sorts the selected array of Orders by price from lower to higher if it's a buy order or from highest to lowest if it's a sell order
/// @param _type The type of order either 'sell' or 'buy'
/// @return uint256[] Returns the sorted ids
function sortIdsByPrices(bytes32 _type) public view returns (uint256[] memory) {
    Order[] memory orders;
    if(_type == 'sell') orders = sellOrders;
    else orders = buyOrders;

    uint256 length = orders.length;
    uint256[] memory orderedIds = new uint256[](length);
    uint256 lastId = 0;
    for(uint i = 0; i < length; i++) {
        if(orders[i].quantity > 0) {
            for(uint j = i+1; j < length; j++) {
                // If it's a buy order, sort from lowest to highest since we want the lowest prices first
                if(_type == 'buy' && orders[i].price > orders[j].price) {
                    Order memory temporaryOrder = orders[i];
                    orders[i] = orders[j];
                    orders[j] = temporaryOrder;
                }
                // If it's a sell order, sort from highest to lowest since we want the highest sell prices first
                if(_type == 'sell' && orders[i].price < orders[j].price) {
                    Order memory temporaryOrder = orders[i];
                    orders[i] = orders[j];
                    orders[j] = temporaryOrder;
                }
            }
            orderedIds[lastId] = orders[i].id;
            lastId++;
        }
    }

    return orderedIds;
}



/// @notice To create a market order by filling one or more existing limit orders at the most profitable price given a token pair, type of order (buy or sell) and the amount of tokens to trade, the _quantity is how many _firstSymbol tokens you want to buy if it's a buy order or how many _firstSymbol tokens you want to sell at market price
/// @param _type The type of order either 'buy' or 'sell'
/// @param _firstSymbol The first token to buy or sell
/// @param _secondSymbol The second token to create a pair
/// @param _quantity The amount of tokens to sell or buy
function marketOrder(bytes32 _type, bytes32 _firstSymbol, bytes32 _secondSymbol, uint256 _quantity) public {
    require(_type.length > 0, 'You must specify the type');
    require(isTokenSymbolWhitelisted[_firstSymbol], 'The first symbol must be whitelisted');
    require(isTokenSymbolWhitelisted[_secondSymbol], 'The second symbol must be whitelisted');
    require(_quantity > 0, 'You must specify the quantity to buy or sell');
    require(checkValidPair(_firstSymbol, _secondSymbol), 'The pair must be a valid pair');

    // Fills the latest market orders up until the _quantity is reached
    uint256[] memory ordersToFillIds;
    uint256[] memory quantitiesToFillPerOrder;
    uint256 currentQuantity = 0;
    if(_type == 'buy') {
        ordersToFillIds = new uint256[](sellOrders.length);
        quantitiesToFillPerOrder = new uint256[](sellOrders.length);
        // Loop through all the sell orders until we fill the quantity
        for(uint256 i = 0; i < sellOrders.length; i++) {
            ordersToFillIds[i] = sellOrders[i].id;
            if((currentQuantity + sellOrders[i].quantity) > _quantity) {
                quantitiesToFillPerOrder[i] = _quantity - currentQuantity;
                break;
            }
            currentQuantity += sellOrders[i].quantity;
            quantitiesToFillPerOrder[i] = sellOrders[i].quantity;
        }
    } else {
        ordersToFillIds = new uint256[](buyOrders.length);
        quantitiesToFillPerOrder = new uint256[](buyOrders.length);
        for(uint256 i = 0; i < buyOrders.length; i++) {
            ordersToFillIds[i] = buyOrders[i].id;
            if((currentQuantity + buyOrders[i].quantity) > _quantity) {
                quantitiesToFillPerOrder[i] = _quantity - currentQuantity;
                break;
            }
            currentQuantity += buyOrders[i].quantity;
            quantitiesToFillPerOrder[i] = buyOrders[i].quantity;
        }
    }

    // When the myOrder.type == sell or _type == buy
    // myOrder.owner send quantityToFill[] of _firstSymbol to msg.sender
    // msg.sender send quantityToFill[] * myOwner.price of _secondSymbol to myOrder.owner

    // When the myOrder.type == buy or _type == sell
    // myOrder.owner send quantityToFill[] * myOwner.price of _secondSymbol to msg.sender
    // msg.sender send quantityToFill[] of _firstSymbol to myOrder.owner

    // Close and fill orders
    for(uint256 i = 0; i < ordersToFillIds.length; i++) {
        Order memory myOrder = orderById[ordersToFillIds[i]];

        // If we fill the entire order, mark it as closed
        if(quantitiesToFillPerOrder[i] == myOrder.quantity) {
            myOrder.state = OrderState.CLOSED;
            closedOrders.push(myOrder);
        }
        myOrder.quantity -= quantitiesToFillPerOrder[i];
        orderById[myOrder.id] = myOrder;

        if(_type == 'buy') {
            // If the limit order is a buy order, send the firstSymbol to the creator of the limit order which is the buyer
            Escrow(escrowByUserAddress[myOrder.owner]).transferTokens(tokenAddressBySymbol[_firstSymbol], msg.sender, quantitiesToFillPerOrder[i]);
            Escrow(escrowByUserAddress[msg.sender]).transferTokens(tokenAddressBySymbol[_secondSymbol], myOrder.owner, quantitiesToFillPerOrder[i] * myOrder.price);

            sellOrders[sellOrderIndexById[myOrder.id]] = myOrder;

            emit TransferOrder('sell', escrowByUserAddress[myOrder.owner], msg.sender, _firstSymbol, quantitiesToFillPerOrder[i]);
            emit TransferOrder('buy', escrowByUserAddress[msg.sender], myOrder.owner, _secondSymbol, quantitiesToFillPerOrder[i] * myOrder.price);
        } else {
            // If this is a buy market order or a sell limit order for the opposite, send firstSymbol to the second user
                Escrow(escrowByUserAddress[myOrder.owner]).transferTokens(tokenAddressBySymbol[_secondSymbol], msg.sender, quantitiesToFillPerOrder[i] * myOrder.price);
            Escrow(escrowByUserAddress[msg.sender]).transferTokens(tokenAddressBySymbol[_firstSymbol], myOrder.owner, quantitiesToFillPerOrder[i]);

            buyOrders[buyOrderIndexById[myOrder.id]] = myOrder;

            emit TransferOrder('buy', escrowByUserAddress[myOrder.owner], msg.sender, _secondSymbol, quantitiesToFillPerOrder[i] * myOrder.price);
            emit TransferOrder('sell', escrowByUserAddress[msg.sender], myOrder.owner, _firstSymbol, quantitiesToFillPerOrder[i]);
        }

    }
}



// We need a system that allows people to trade different pairs of ERC20 tokens. Only approved tokens will be tradable since we don't want to clutter the system with an endless list of unused tokens. As a proof of concept, we'll trade only ETH - HYDRO since hydro is a famous ERC20 token that has a test token available outside the mainnet in rinkeby.

// Functions that we need:
/*
    1. Constructor to setup the owner
    2. Fallback non-payable function to reject ETH from direct transfers since we only want people to use the functions designed to trade a specific pair
    3. Function to extract tokens from this contract in case someone mistakenly sends ERC20 to the wrong function
    4. Function to create whitelist a token by the owner
    5. Function to create market orders
    6. Function to create limit orders
 */

pragma solidity ^0.5.4;

import './Escrow.sol';

contract DAX {
    event TransferOrder(bytes32 _type, address indexed from, address indexed to, bytes32 tokenSymbol, uint256 quantity);
    enum OrderState {OPEN, CLOSED}

    struct Order {
        uint256 id;
        address owner;
        bytes32 orderType;
        bytes32 firstSymbol;
        bytes32 secondSymbol;
        uint256 quantity;
        uint256 price;
        uint256 timestamp;
        OrderState state;
    }

    Order[] public buyOrders;
    Order[] public sellOrders;
    Order[] public closedOrders;
    uint256 public orderIdCounter;
    address public owner;
    address[] public whitelistedTokens;
    bytes32[] public whitelistedTokenSymbols;
    address[] public users;

    // Token address => isWhitelisted or not
    mapping(address => bool) public isTokenWhitelisted;
    mapping(bytes32 => bool) public isTokenSymbolWhitelisted;
    mapping(bytes32 => bytes32[]) public tokenPairs; // A token symbol pair made of 'FIRST' => 'SECOND'
    mapping(bytes32 => address) public tokenAddressBySymbol; // Symbol => address of the token
    mapping(uint256 => Order) public orderById; // Id => trade object
    mapping(uint256 => uint256) public buyOrderIndexById; // Id => index inside the buyOrders array
    mapping(uint256 => uint256) public sellOrderIndexById; // Id => index inside the sellOrders array
    mapping(address => address) public escrowByUserAddress; // User address => escrow contract address

    modifier onlyOwner {
        require(msg.sender == owner, 'The sender must be the owner for this function');
        _;
    }

    /// @notice Users should not send ether to this contract
    function () external {
        revert();
    }

    constructor () public {
        owner = msg.sender;
    }

    /// @notice To whitelist a token so that is tradable in the exchange
    /// @dev If the transaction reverts, it could be because of the quantity of token pairs, try reducing the number and breaking the transaction into several pieces
    /// @param _symbol The symbol of the token
    /// @param _token The token to whitelist, for instance 'TOK'
    /// @param _tokenPairSymbols The token pairs to whitelist for this new token, for instance: ['BAT', 'HYDRO'] which will be converted to ['TOK', 'BAT'] and ['TOK', 'HYDRO']
    /// @param _tokenPairAddresses The token pair addresses to whitelist for this new token, for instance: ['0x213...', '0x927...', '0x128...']
    function whitelistToken(bytes32 _symbol, address _token, bytes32[] memory _tokenPairSymbols, address[] memory _tokenPairAddresses) public onlyOwner {
        require(_token != address(0), 'You must specify the token address to whitelist');
        require(IERC20(_token).totalSupply() > 0, 'The token address specified is not a valid ERC20 token');
        require(_tokenPairAddresses.length == _tokenPairSymbols.length, 'You must send the same number of addresses and symbols');

        isTokenWhitelisted[_token] = true;
        isTokenSymbolWhitelisted[_symbol] = true;
        whitelistedTokens.push(_token);
        whitelistedTokenSymbols.push(_symbol);
        tokenAddressBySymbol[_symbol] = _token;
        tokenPairs[_symbol] = _tokenPairSymbols;

        for(uint256 i = 0; i < _tokenPairAddresses.length; i++) {
            address currentAddress = _tokenPairAddresses[i];
            bytes32 currentSymbol = _tokenPairSymbols[i];
            tokenPairs[currentSymbol].push(_symbol);
            if(!isTokenWhitelisted[currentAddress]) {
                isTokenWhitelisted[currentAddress] = true;
                isTokenSymbolWhitelisted[currentSymbol] = true;
                whitelistedTokens.push(currentAddress);
                whitelistedTokenSymbols.push(currentSymbol);
                tokenAddressBySymbol[currentSymbol] = currentAddress;
            }
        }
    }

    /// @notice To store tokens inside the escrow contract associated with the user accounts as long as the users made an approval beforehand
    /// @dev It will revert is the user doesn't approve tokens beforehand to this contract
    /// @param _token The token address
    /// @param _amount The quantity to deposit to the escrow contracc
    function depositTokens(address _token, uint256 _amount) public {
        require(isTokenWhitelisted[_token], 'The token to deposit must be whitelisted');
        require(_token != address(0), 'You must specify the token address');
        require(_amount > 0, 'You must send some tokens with this deposit function');
        require(IERC20(_token).allowance(msg.sender, address(this)) >= _amount, 'You must approve() the quantity of tokens that you want to deposit first');
        if(escrowByUserAddress[msg.sender] == address(0)) {
            Escrow newEscrow = new Escrow(address(this));
            escrowByUserAddress[msg.sender] = address(newEscrow);
            users.push(msg.sender);
        }
        IERC20(_token).transferFrom(msg.sender, escrowByUserAddress[msg.sender], _amount);
    }

    /// @notice To extract tokens
    /// @param _token The token address to extract
    /// @param _amount The amount of tokens to transfer
    function extractTokens(address _token, uint256 _amount) public {
        require(_token != address(0), 'You must specify the token address');
        require(_amount > 0, 'You must send some tokens with this deposit function');
        Escrow(escrowByUserAddress[msg.sender]).transferTokens(_token, msg.sender, _amount);
    }

    /// @notice To create a market order by filling one or more existing limit orders at the most profitable price given a token pair, type of order (buy or sell) and the amount of tokens to trade, the _quantity is how many _firstSymbol tokens you want to buy if it's a buy order or how many _firstSymbol tokens you want to sell at market price
    /// @param _type The type of order either 'buy' or 'sell'
    /// @param _firstSymbol The first token to buy or sell
    /// @param _secondSymbol The second token to create a pair
    /// @param _quantity The amount of tokens to sell or buy
    function marketOrder(bytes32 _type, bytes32 _firstSymbol, bytes32 _secondSymbol, uint256 _quantity) public {
        require(_type.length > 0, 'You must specify the type');
        require(isTokenSymbolWhitelisted[_firstSymbol], 'The first symbol must be whitelisted');
        require(isTokenSymbolWhitelisted[_secondSymbol], 'The second symbol must be whitelisted');
        require(_quantity > 0, 'You must specify the quantity to buy or sell');
        require(checkValidPair(_firstSymbol, _secondSymbol), 'The pair must be a valid pair');

        // Fills the latest market orders up until the _quantity is reached
        uint256[] memory ordersToFillIds;
        uint256[] memory quantitiesToFillPerOrder;
        uint256 currentQuantity = 0;
        if(_type == 'buy') {
            ordersToFillIds = new uint256[](sellOrders.length);
            quantitiesToFillPerOrder = new uint256[](sellOrders.length);
            // Loop through all the sell orders until we fill the quantity
            for(uint256 i = 0; i < sellOrders.length; i++) {
                ordersToFillIds[i] = sellOrders[i].id;
                if((currentQuantity + sellOrders[i].quantity) > _quantity) {
                    quantitiesToFillPerOrder[i] = _quantity - currentQuantity;
                    break;
                }
                currentQuantity += sellOrders[i].quantity;
                quantitiesToFillPerOrder[i] = sellOrders[i].quantity;
            }
        } else {
            ordersToFillIds = new uint256[](buyOrders.length);
            quantitiesToFillPerOrder = new uint256[](buyOrders.length);
            for(uint256 i = 0; i < buyOrders.length; i++) {
                ordersToFillIds[i] = buyOrders[i].id;
                if((currentQuantity + buyOrders[i].quantity) > _quantity) {
                    quantitiesToFillPerOrder[i] = _quantity - currentQuantity;
                    break;
                }
                currentQuantity += buyOrders[i].quantity;
                quantitiesToFillPerOrder[i] = buyOrders[i].quantity;
            }
        }

        // When the myOrder.type == sell or _type == buy
        // myOrder.owner send quantityToFill[] of _firstSymbol to msg.sender
        // msg.sender send quantityToFill[] * myOwner.price of _secondSymbol to myOrder.owner

        // When the myOrder.type == buy or _type == sell
        // myOrder.owner send quantityToFill[] * myOwner.price of _secondSymbol to msg.sender
        // msg.sender send quantityToFill[] of _firstSymbol to myOrder.owner

        // Close and fill orders
        for(uint256 i = 0; i < ordersToFillIds.length; i++) {
            Order memory myOrder = orderById[ordersToFillIds[i]];

            // If we fill the entire order, mark it as closed
            if(quantitiesToFillPerOrder[i] == myOrder.quantity) {
                myOrder.state = OrderState.CLOSED;
                closedOrders.push(myOrder);
            }
            myOrder.quantity -= quantitiesToFillPerOrder[i];
            orderById[myOrder.id] = myOrder;

            if(_type == 'buy') {
                // If the limit order is a buy order, send the firstSymbol to the creator of the limit order which is the buyer
                Escrow(escrowByUserAddress[myOrder.owner]).transferTokens(tokenAddressBySymbol[_firstSymbol], msg.sender, quantitiesToFillPerOrder[i]);
                Escrow(escrowByUserAddress[msg.sender]).transferTokens(tokenAddressBySymbol[_secondSymbol], myOrder.owner, quantitiesToFillPerOrder[i] * myOrder.price);

                sellOrders[sellOrderIndexById[myOrder.id]] = myOrder;

                emit TransferOrder('sell', escrowByUserAddress[myOrder.owner], msg.sender, _firstSymbol, quantitiesToFillPerOrder[i]);
                emit TransferOrder('buy', escrowByUserAddress[msg.sender], myOrder.owner, _secondSymbol, quantitiesToFillPerOrder[i] * myOrder.price);
            } else {
                // If this is a buy market order or a sell limit order for the opposite, send firstSymbol to the second user
                Escrow(escrowByUserAddress[myOrder.owner]).transferTokens(tokenAddressBySymbol[_secondSymbol], msg.sender, quantitiesToFillPerOrder[i] * myOrder.price);
                Escrow(escrowByUserAddress[msg.sender]).transferTokens(tokenAddressBySymbol[_firstSymbol], myOrder.owner, quantitiesToFillPerOrder[i]);

                buyOrders[buyOrderIndexById[myOrder.id]] = myOrder;

                emit TransferOrder('buy', escrowByUserAddress[myOrder.owner], msg.sender, _secondSymbol, quantitiesToFillPerOrder[i] * myOrder.price);
                emit TransferOrder('sell', escrowByUserAddress[msg.sender], myOrder.owner, _firstSymbol, quantitiesToFillPerOrder[i]);
            }
        }
    }

    /// @notice To create a market order given a token pair, type of order, amount of tokens to trade and the price per token. If the type is buy, the price will determine how many _secondSymbol tokens you are willing to pay for each _firstSymbol up until your _quantity or better if there are more profitable prices. If the type if sell, the price will determine how many _secondSymbol tokens you get for each _firstSymbol
    /// @param _type The type of order either 'buy' or 'sell'
    /// @param _firstSymbol The first symbol to deal with
    /// @param _secondSymbol The second symbol that you want to deal
    /// @param _quantity How many tokens you want to deal, these are _firstSymbol tokens
    /// @param _pricePerToken How many tokens you get or pay for your other symbol, the total quantity is _pricePerToken * _quantity
    function limitOrder(bytes32 _type, bytes32 _firstSymbol, bytes32 _secondSymbol, uint256 _quantity, uint256 _pricePerToken) public {
        address userEscrow = escrowByUserAddress[msg.sender];
        address firstSymbolAddress = tokenAddressBySymbol[_firstSymbol];
        address secondSymbolAddress = tokenAddressBySymbol[_secondSymbol];

        require(firstSymbolAddress != address(0), 'The first symbol has not been whitelisted');
        require(secondSymbolAddress != address(0), 'The second symbol has not been whitelisted');
        require(isTokenSymbolWhitelisted[_firstSymbol], 'The first symbol must be whitelisted to trade with it');
        require(isTokenSymbolWhitelisted[_secondSymbol], 'The second symbol must be whitelisted to trade with it');
        require(userEscrow != address(0), 'You must deposit some tokens before creating orders, use depositToken()');
        require(checkValidPair(_firstSymbol, _secondSymbol), 'The pair must be a valid pair');

        Order memory myOrder = Order(orderIdCounter, msg.sender, _type, _firstSymbol, _secondSymbol, _quantity, _pricePerToken, now, OrderState.OPEN);
        orderById[orderIdCounter] = myOrder;
        if(_type == 'buy') {
            // Check that the user has enough of the second symbol if he wants to buy the first symbol at that price
            require(IERC20(secondSymbolAddress).balanceOf(userEscrow) >= _quantity, 'You must have enough second token funds in your escrow contract to create this buy order');

            buyOrders.push(myOrder);

            // Sort existing orders by price the most efficient way possible, we could optimize even more by creating a buy array for each token
            uint256[] memory sortedIds = sortIdsByPrices('buy');
            delete buyOrders;
            buyOrders.length = sortedIds.length;
            for(uint256 i = 0; i < sortedIds.length; i++) {
                buyOrders[i] = orderById[sortedIds[i]];
                buyOrderIndexById[sortedIds[i]] = i;
            }
        } else {
            // Check that the user has enough of the first symbol if he wants to sell it for the second symbol
            require(IERC20(firstSymbolAddress).balanceOf(userEscrow) >= _quantity, 'You must have enough first token funds in your escrow contract to create this sell order');

            // Add the new order
            sellOrders.push(myOrder);

            // Sort existing orders by price the most efficient way possible, we could optimize even more by creating a sell array for each token
            uint256[] memory sortedIds = sortIdsByPrices('sell');
            delete sellOrders; // Reset orders
            sellOrders.length = sortedIds.length;
            for(uint256 i = 0; i < sortedIds.length; i++) {
                sellOrders[i] = orderById[sortedIds[i]];
                sellOrderIndexById[sortedIds[i]] = i;
            }
        }

        orderIdCounter++;
    }

    /// @notice Sorts the selected array of Orders by price from lower to higher if it's a buy order or from highest to lowest if it's a sell order
    /// @param _type The type of order either 'sell' or 'buy'
    /// @return uint256[] Returns the sorted ids
    function sortIdsByPrices(bytes32 _type) public view returns (uint256[] memory) {
        Order[] memory orders;
        if(_type == 'sell') orders = sellOrders;
        else orders = buyOrders;

        uint256 length = orders.length;
        uint256[] memory orderedIds = new uint256[](length);
        uint256 lastId = 0;
        for(uint i = 0; i < length; i++) {
            if(orders[i].quantity > 0) {
                for(uint j = i+1; j < length; j++) {
                    // If it's a buy order, sort from lowest to highest since we want the lowest prices first
                    if(_type == 'buy' && orders[i].price > orders[j].price) {
                        Order memory temporaryOrder = orders[i];
                        orders[i] = orders[j];
                        orders[j] = temporaryOrder;
                    }
                    // If it's a sell order, sort from highest to lowest since we want the highest sell prices first
                    if(_type == 'sell' && orders[i].price < orders[j].price) {
                        Order memory temporaryOrder = orders[i];
                        orders[i] = orders[j];
                        orders[j] = temporaryOrder;
                    }
                }
                orderedIds[lastId] = orders[i].id;
                lastId++;
            }
        }

        return orderedIds;
    }


    /// @notice Checks if a pair is valid
    /// @param _firstSymbol The first symbol of the pair
    /// @param _secondSymbol The second symbol of the pair
    /// @return bool If the pair is valid or not
    function checkValidPair(bytes32 _firstSymbol, bytes32 _secondSymbol) public view returns(bool) {
        bytes32[] memory pairs = tokenPairs[_firstSymbol];

        for(uint256 i = 0; i < pairs.length; i++){
            if(pairs[i] == _secondSymbol) return true;
        }
        return false;
    }

    /// @notice Returns the token pairs
    /// @param _token To get the array of token pair for that selected token
    /// @return bytes32[] An array containing the pairs
    function getTokenPairs(bytes32 _token) public view returns(bytes32[] memory) {
        return tokenPairs[_token];
    }

    /// @notice To get an order from the arrays of orders
    /// @param _type The type of order to get
    /// @param _index The index of the order to get
    /// @return Order The order struct
    function getOrder(bytes32 _type, uint256 _index) public view returns(uint256, address, bytes32, bytes32, bytes32, uint256, uint256, uint256, OrderState) {
        Order memory myOrder;
        if(_type == 'buy') {
             myOrder = buyOrders[_index];
        } else if(_type == 'sell') {
            myOrder = sellOrders[_index];
        } else if(_type == 'closed') {
            myOrder = closedOrders[_index];
        }
        return (myOrder.id, myOrder.owner, myOrder.orderType, myOrder.firstSymbol, myOrder.secondSymbol, myOrder.quantity, myOrder.price, myOrder.timestamp, myOrder.state);
    }

    /// @notice To get the length of the specified order array
    /// @param _type The type of order
    /// @return uint256 The number of elements inside that order
    function getOrderLength(bytes32 _type) public view returns(uint256) {
        if(_type == 'buy') {
            return buyOrders.length;
        } else if(_type == 'sell') {
            return sellOrders.length;
        } else if(_type == 'closed') {
            return closedOrders.length;
        }
    }

    /// @notice To get all the whitelisted symbols
    /// @return bytes32[] The array of symbols
    function getWhitelistedTokenSymbols() public view returns(bytes32[] memory) {
        return whitelistedTokenSymbols;
    }
}



import React from 'react'
import ReactDOM from 'react-dom'
import MyWeb3 from 'web3'
import './index.styl'
import ABI from '../build/contracts/DAX.json'
import TokenABI from '../build/contracts/ERC20.json'

const batToken = '0x850Cbb38828adF8a89d7d799CCf1010Dc238F665'
const watToken = '0x029cc401Ef45B2a2B2D6D2D6677b9F94E26cfF9d'
const dax = ABI.networks['3'].address




class Main extends React.Component {
    constructor() {
        super()

        this.state = {
            contractInstance: {},
            tokenInstance: {},
            secondTokenInstance: {},
            userAddress: '',
            firstSymbol: 'BAT', // Sample tokens
            secondSymbol: 'WAT', // Sample tokens
            balanceFirstSymbol: 0,
            balanceSecondSymbol: 0,
            escrow: '',
            buyOrders: [],
            sellOrders: [],
            closedOrders: []
        }

        this.setup()
    }

    // To use bytes32 functions
    bytes32(name) {
        return myWeb3.utils.fromAscii(name)
    }

    async setup() {
        // Create the contract instance
        window.myWeb3 = new MyWeb3(ethereum)
        try {
            await ethereum.enable();
        } catch (error) {
            console.error('You must approve this dApp to interact with it')
        }
        console.log('Setting up contract instances')
        await this.setContractInstances()
        console.log('Setting up orders')
        await this.setOrders()
        console.log('Setting up pairs')
        await this.setPairs()
    }

    async setContractInstances() {
        const userAddress = (await myWeb3.eth.getAccounts())[0]
        if(!userAddress) return console.error('You must unlock metamask to use this dApp on ropsten!')
        await this.setState({userAddress})
        const contractInstance = new myWeb3.eth.Contract(ABI.abi, dax, {
            from: this.state.userAddress,
            gasPrice: 2e9
        })
        const tokenInstance = new myWeb3.eth.Contract(TokenABI.abi, batToken, {
            from: this.state.userAddress,
            gasPrice: 2e9
        })
        const secondTokenInstance = new myWeb3.eth.Contract(TokenABI.abi, watToken, {
            from: this.state.userAddress,
            gasPrice: 2e9
        })
        await this.setState({contractInstance, tokenInstance, secondTokenInstance})
    }

    async setOrders() {
        // First get the length of all the orders so that you can loop through them
        const buyOrdersLength = await this.state.contractInstance.methods.getOrderLength(this.bytes32("buy")).call({ from: this.state.userAddress })
        const sellOrdersLength = await this.state.contractInstance.methods.getOrderLength(this.bytes32('sell')).call({ from: this.state.userAddress })
        const closedOrdersLength = await this.state.contractInstance.methods.getOrderLength(this.bytes32('closed')).call({ from: this.state.userAddress })
        let buyOrders = []
        let sellOrders = []
        let closedOrders = []

        for(let i = 0; i < buyOrdersLength; i++) {
            const order = await this.state.contractInstance.methods.getOrder(this.bytes32('buy'), i).call({ from: this.state.userAddress })
            const orderObject = {
                id: order[0],
                owner: order[1],
                type: myWeb3.utils.toUtf8(order[2]),
                firstSymbol: myWeb3.utils.toUtf8(order[3]),
                secondSymbol: myWeb3.utils.toUtf8(order[4]),
                quantity: order[5],
                price: order[6],
                timestamp: order[7],
                state: order[8],
            }
            buyOrders.push(orderObject)
        }
        for(let i = 0; i < sellOrdersLength; i++) {
            const order = await this.state.contractInstance.methods.getOrder(this.bytes32('sell'), 0).call({ from: this.state.userAddress })
            const orderObject = {
                id: order[0],
                owner: order[1],
                type: myWeb3.utils.toUtf8(order[2]),
                firstSymbol: myWeb3.utils.toUtf8(order[3]),
                secondSymbol: myWeb3.utils.toUtf8(order[4]),
                quantity: order[5],
                price: order[6],
                timestamp: order[7],
                state: order[8],
            }
            sellOrders.push(orderObject)
        }
        for(let i = 0; i < closedOrdersLength; i++) {
            const order = await this.state.contractInstance.methods.closedOrders(this.bytes32('close'), 0).call({ from: this.state.userAddress })
            const orderObject = {
                id: order[0],
                owner: order[1],
                type: myWeb3.utils.toUtf8(order[2]),
                firstSymbol: myWeb3.utils.toUtf8(order[3]),
                secondSymbol: myWeb3.utils.toUtf8(order[4]),
                quantity: order[5],
                price: order[6],
                timestamp: order[7],
                state: order[8],
            }
            closedOrders.push(orderObject)
        }
        this.setState({buyOrders, sellOrders, closedOrders})
    }

    async setPairs() {
        // Here you'd add all the logic to get all the token symbols, in this case we're keeping it simple with one fixed pair
        // If there are no pairs, whitelist a new one automatically if this is the owner of the DAX contract
        const owner = await this.state.contractInstance.methods.owner().call({ from: this.state.userAddress })
        const isWhitelisted = await this.state.contractInstance.methods.isTokenWhitelisted(batToken).call({ from: this.state.userAddress })
        if(owner == this.state.userAddress && !isWhitelisted) {
            await this.state.contractInstance.methods.whitelistToken(this.bytes32('BAT'), batToken, [this.bytes32('WAT')], [watToken]).send({ from: this.state.userAddress, gas: 8e6 })
        }

        // Set the balance of each symbol considering how many tokens you have in escrow
        const escrow = await this.state.contractInstance.methods.escrowByUserAddress(this.state.userAddress).call({ from: this.state.userAddress })
        const balanceOne = await this.state.tokenInstance.methods.balanceOf(escrow).call({ from: this.state.userAddress })
        const balanceTwo = await this.state.secondTokenInstance.methods.balanceOf(escrow).call({ from: this.state.userAddress })
        this.setState({escrow, balanceOne, balanceTwo})
    }
}




async whitelistTokens(symbol, token, pairSymbols, pairAddresses) {
    await this.state.contractInstance.methods.whitelistToken(this.bytes32(symbol), token, pairSymbols, pairAddresses).send({ from: this.state.userAddress })
}

async depositTokens(symbol, amount) {
    if(symbol == 'BAT') {
        // Check the token balace before approving
        const balance = await this.state.tokenInstance.methods.balanceOf(this.state.userAddress).call({ from: this.state.userAddress })
        if(balance < amount) return alert(`You can't deposit ${amount} BAT since you have ${balance} BAT in your account, get more tokens before depositing`)
        // First approve to 0 to avoid errors and then increase it
        await this.state.tokenInstance.methods.approve(dax, 0).send({ from: this.state.userAddress })
        await this.state.tokenInstance.methods.approve(dax, amount).send({ from: this.state.userAddress })
        // Create the transaction
        await this.state.contractInstance.methods.depositTokens(batToken, amount).send({ from: this.state.userAddress })
    } else if(symbol == 'WAT') {
        // Check the token balace before approving
        const balance = await this.state.secondTokenInstance.methods.balanceOf(this.state.userAddress).call({ from: this.state.userAddress })
        if(balance < amount) return alert(`You can't deposit ${amount} WAT since you have ${balance} WAT in your account, get more tokens before depositing`)
        // First approve to 0 to avoid errors and then increase it
        await this.state.secondTokenInstance.methods.approve(dax, 0).send({ from: this.state.userAddress })
        await this.state.secondTokenInstance.methods.approve(dax, amount).send({ from: this.state.userAddress })
        // Create the transaction
        await this.state.contractInstance.methods.depositTokens(watToken, amount).send({ from: this.state.userAddress })
    }
}

async withdrawTokens(symbol, amount) {
    if(symbol == 'BAT') {
        await this.state.contractInstance.methods.extractTokens(batToken, amount).send({ from: this.state.userAddress })
    } else if(symbol == 'WAT') {
        await this.state.contractInstance.methods.extractTokens(watToken, amount).send({ from: this.state.userAddress })
    }
}

async createLimitOrder(type, firstSymbol, secondSymbol, quantity, pricePerToken) {
    // Create the limit order
    await this.state.contractInstance.methods.limitOrder(type, firstSymbol, secondSymbol, quantity, pricePerToken).send({ from: this.state.userAddress })
}

async createMarketOrder(type, firstSymbol, secondSymbol, quantity) {
    // Create the market order
    await this.state.contractInstance.methods.marketOrder(type, firstSymbol, secondSymbol, quantity).send({ from: this.state.userAddress })
}



render() {
    return (
        <div className="main-container">
            <Sidebar
                firstSymbol={this.state.firstSymbol}
                secondSymbol={this.state.secondSymbol}
                balanceOne={this.state.balanceOne}
                balanceTwo={this.state.balanceTwo}
                deposit={(symbol, amount) => this.depositTokens(symbol, amount)}
                withdraw={(symbol, amount) => this.withdrawTokens(symbol, amount)}
                limitOrder={(type, firstSymbol, secondSymbol, quantity, pricePerToken) => this.createLimitOrder(type, firstSymbol, secondSymbol, quantity, pricePerToken)}
                marketOrder={(type, firstSymbol, secondSymbol, quantity) => this.createMarketOrder(type, firstSymbol, secondSymbol, quantity)}
            />
            <Orders
                buyOrders={this.state.buyOrders}
                sellOrders={this.state.sellOrders}
            />
            <History
                closedOrders={this.state.closedOrders}
            />
        </div>
    )
}




class Sidebar extends React.Component {
    constructor() {
        super()
        this.state = {
            selectedLimitOrder: false,
            limitOrderPrice: 0,
            orderQuantity: 0,
        }
    }

    // To use bytes32 functions
    bytes32(name) {
        return myWeb3.utils.fromAscii(name)
    }

    resetInputs() {
        this.refs.limitOrderPrice.value = ''
        this.refs.orderQuantity.value = ''
        this.setState({
            limitOrderPrice: 0,
            orderQuantity: 0,
        })
    }

    render() {
        return (
            <div className="sidebar">
                <div className="selected-assets-title heading">Selected assets</div>
                <div className="selected-asset-one">{this.props.firstSymbol}</div>
                <div className="selected-asset-two">{this.props.secondSymbol}</div>
                <div className="your-portfolio heading">Your portfolio</div>
                <div className="grid-center">{this.props.firstSymbol}:</div><div className="grid-center">{this.props.balanceOne ? this.props.balanceOne : 'Loading...'}</div>
                <div className="grid-center">{this.props.secondSymbol}:</div><div className="grid-center">{this.props.balanceTwo ? this.props.balanceTwo : 'Loading...'}</div>
                <div className="money-management heading">Money management</div>
                <button className="button-outline" onClick={() => {
                    const amount = prompt(`How many ${this.props.firstSymbol} tokens do you want to deposit?`)
                    this.props.deposit(this.props.firstSymbol, amount)
                }}>Deposit {this.props.firstSymbol} </button>
                <button className="button-outline" onClick={() => {
                    const amount = prompt(`How many ${this.props.firstSymbol} tokens do you want to withdraw?`)
                    this.props.withdraw(this.props.firstSymbol, amount)
                }}>Withdraw {this.props.firstSymbol}</button>
                <button className="button-outline" onClick={() => {
                    const amount = prompt(`How many ${this.props.secondSymbol} tokens do you want to deposit?`)
                    this.props.deposit(this.props.secondSymbol, amount)
                }}>Deposit {this.props.secondSymbol} </button>
                <button className="button-outline" onClick={() => {
                    const amount = prompt(`How many ${this.props.secondSymbol} tokens do you want to withdraw?`)
                    this.props.withdraw(this.props.secondSymbol, amount)
                }}>Withdraw {this.props.secondSymbol}</button>
                <div className="actions heading">Actions</div>
                <button onClick={() => {
                    if(this.state.orderQuantity == 0) return alert('You must specify how many tokens you want to buy')
                    if(this.state.selectedLimitOrder) {
                        if(this.state.limitOrderPrice == 0) return alert('You must specify the token price at which you want to buy')
                        if(this.props.balanceTwo < (this.state.orderQuantity * this.state.limitOrderPrice)) {
                            return alert(`You must approve ${this.state.orderQuantity * this.state.limitOrderPrice} of ${this.props.secondSymbol} tokens to create this buy limit order, your ${this.props.secondSymbol} token balance must be larger than ${this.state.orderQuantity * this.state.limitOrderPrice}`)
                        }
                        // Buy the this.state.orderQuantity of this.props.firstSymbol
                        this.props.limitOrder(this.bytes32('buy'), this.bytes32(this.props.firstSymbol), this.bytes32(this.props.secondSymbol), this.state.orderQuantity, this.state.limitOrderPrice)
                    } else {
                        this.props.marketOrder(this.bytes32('buy'), this.bytes32(this.props.firstSymbol), this.bytes32(this.props.secondSymbol), this.state.orderQuantity)
                    }
                    this.resetInputs()
                }}>Buy {this.props.firstSymbol}</button>
                <button onClick={() => {
                    if(this.state.orderQuantity == 0) return alert('You must specify how many tokens you want to sell')
                    if(this.state.selectedLimitOrder) {
                        if(this.state.limitOrderPrice == 0) return alert('You must specify the token price at which you want to sell')
                        if(this.props.balanceOne < this.state.orderQuantity) {
                            return alert(`You must approve ${this.state.orderQuantity} of ${this.props.firstSymbol} tokens to create this sell limit order, your ${this.props.firstSymbol} token balance must be larger than ${this.state.orderQuantity}`)
                        }
                        // Buy the this.state.orderQuantity of this.props.firstSymbol
                        this.props.limitOrder(this.bytes32('sell'), this.bytes32(this.props.firstSymbol), this.bytes32(this.props.secondSymbol), this.state.orderQuantity, this.state.limitOrderPrice)
                    } else {
                        this.props.marketOrder(this.bytes32('sell'), this.bytes32(this.props.firstSymbol), this.bytes32(this.props.secondSymbol), this.state.orderQuantity)
                    }
                    this.resetInputs()
                }} className="sell">Sell {this.props.firstSymbol}</button>
                <select defaultValue="market-order" onChange={selected => {
                    if(selected.target.value == 'limit-order') {
                        this.setState({selectedLimitOrder: true})
                    } else {
                        this.setState({selectedLimitOrder: false})
                    }
                }}>
                    <option value="market-order">Market Order</option>
                    <option value="limit-order">Limit Order</option>
                </select>
                <input ref="limitOrderPrice" onChange={event => {
                    this.setState({limitOrderPrice: event.target.value})
                }} className={this.state.selectedLimitOrder ? '' : 'hidden'} type="number" placeholder="Price to buy or sell at..." />
                <input ref="orderQuantity" onChange={event => {
                    this.setState({orderQuantity: event.target.value})
                }} type="number" placeholder={`Quantity of ${this.props.firstSymbol} to buy or sell...`} />
            </div>
        )
    }
}



// The main section to see live trades taking place
class Orders extends React.Component {
    constructor() {
        super()
    }

    render() {
        let buyOrders = this.props.buyOrders
        let sellOrders = this.props.sellOrders
        if(buyOrders.length > 0) {
            buyOrders = buyOrders.map((trade, index) => (
                <div key={trade.id + index} className="trade-container buy-trade">
                    <div className="trade-symbol">{trade.firstSymbol}</div>
                    <div className="trade-symbol">{trade.secondSymbol}</div>
                    <div className="trade-pricing">{trade.type} {trade.quantity} {trade.secondSymbol} at {trade.price} {trade.secondSymbol} each</div>
                </div>
            ))
        }

        if(sellOrders.length > 0) {
            sellOrders = sellOrders.map((trade, index) => (
                <div key={trade.id + index} className="trade-container sell-trade">
                    <div className="trade-symbol">{trade.firstSymbol}</div>
                    <div className="trade-symbol">{trade.secondSymbol}</div>
                    <div className="trade-pricing">{trade.type} {trade.quantity} {trade.secondSymbol} at {trade.price} {trade.secondSymbol} each</div>
                </div>
            ))
        }
        return (
            <div className="trades">
                <div className="buy-trades-title heading">Buy</div>
                <div className="buy-trades-container">{buyOrders}</div>
                <div className="sell-trades-title heading">Sell</div>
                <div className="sell-trades-container">{sellOrders}</div>
            </div>
        )
    }
}




// Past historical trades
class History extends React.Component {
    constructor() {
        super()
    }

    render() {
        let closedOrders = this.props.closedOrders
        if(closedOrders.length > 0) {
            closedOrders = closedOrders.map((trade, index) => (
                <div key={trade.id + index} className="historical-trade">
                    <div className={trade.type == 'sell' ? 'sell-trade' : 'buy-trade'}>{trade.type} {trade.quantity} {trade.firstSymbol} for {trade.quantity * trade.price} {trade.secondSymbol} at {trade.price} each</div>
                </div>
            ))
        }
        return (
            <div className="history">
                <div className="heading">Recent history</div>
                <div className="historical-trades-container">{closedOrders}</div>
            </div>
        )
    }
}

ReactDOM.render(<Main />, document.querySelector('#root'))
